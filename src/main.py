"""
Point d'entr√©e principal de l'application Chat LLM.
Configure et lance l'interface utilisateur Streamlit.
"""
import os
import time
import asyncio
import json
import aiohttp
from typing import Optional, Dict, List
import streamlit as st
from loguru import logger

from api.base import ProviderType, ModelType, Message, LLMProvider
from api.mistral import MistralProvider
from api.gemini import GeminiProvider
from api.lm_studio import LMStudioProvider
from api.ollama import OllamaProvider
from config.settings import ConfigManager
from audio.manager import AudioManager, AudioError

# Configuration de la page Streamlit
st.set_page_config(
    page_title="Chat LLM",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Initialisation des √©tats de session
if "messages" not in st.session_state:
    st.session_state.messages = []

if "audio_manager" not in st.session_state:
    st.session_state.audio_manager = AudioManager()

if "config_manager" not in st.session_state:
    st.session_state.config_manager = ConfigManager()

if "loop" not in st.session_state:
    st.session_state.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(st.session_state.loop)

if "selected_provider" not in st.session_state:
    st.session_state.selected_provider = "mistral"

if "current_provider" not in st.session_state:
    st.session_state.current_provider = None

def run_async(coro):
    """
    Ex√©cute une coroutine de mani√®re synchrone.
    
    Args:
        coro: Coroutine √† ex√©cuter
        
    Returns:
        R√©sultat de la coroutine
    """
    try:
        return asyncio.run(coro)
    except RuntimeError:
        # Si un event loop existe d√©j√†
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(coro)

async def get_ollama_models(base_url: str) -> List[str]:
    """
    R√©cup√®re la liste des mod√®les disponibles sur Ollama.
    
    Args:
        base_url: URL de l'API Ollama

    Returns:
        Liste des noms de mod√®les
    """
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{base_url}/api/tags") as resp:
                if resp.status == 200:
                    data = await resp.json()
                    if 'models' in data:
                        # La r√©ponse contient tous les mod√®les sous forme de liste
                        return sorted([model['name'] for model in data['models']])
                    else:
                        logger.warning("Format de r√©ponse Ollama inattendu")
                        return ["mistral", "llama2"]
                else:
                    error_detail = await resp.text()
                    logger.error(f"Erreur lors de la r√©cup√©ration des mod√®les: {error_detail}")
    except Exception as e:
        logger.warning(f"Erreur lors de la r√©cup√©ration des mod√®les Ollama: {e}")
    
    # Liste par d√©faut si erreur
    return ["mistral", "llama2", "codellama", "mixtral"]

async def initialize_provider(provider_type: ProviderType) -> Optional[LLMProvider]:
    """
    Initialise un provider LLM.

    Args:
        provider_type: Type de provider √† initialiser

    Returns:
        Instance du provider initialis√© ou None en cas d'erreur
    """
    try:
        config = st.session_state.config_manager.get_model_config(provider_type)
        
        if provider_type == ProviderType.MISTRAL:
            provider = MistralProvider(config)
        elif provider_type == ProviderType.GEMINI:
            provider = GeminiProvider(config)
        elif provider_type == ProviderType.LM_STUDIO:
            provider = LMStudioProvider(config)
        elif provider_type == ProviderType.OLLAMA:
            provider = OllamaProvider(config)
        else:
            st.warning(f"Provider {provider_type} non impl√©ment√©")
            return None

        await provider.initialize()
        return provider
    
    except Exception as e:
        st.error(f"Erreur d'initialisation du provider {provider_type}: {e}")
        return None

async def change_provider(new_provider: str):
    """
    Change le provider actuel de mani√®re s√©curis√©e.

    Args:
        new_provider: Nom du nouveau provider
    """
    # On met d'abord √† jour le provider s√©lectionn√©
    st.session_state.selected_provider = new_provider
    
    # Si un provider est d√©j√† initialis√©, on le ferme proprement
    if st.session_state.current_provider:
        try:
            await st.session_state.current_provider.close()
        except Exception as e:
            logger.warning(f"Erreur lors de la fermeture du provider: {e}")
        finally:
            st.session_state.current_provider = None

def render_sidebar():
    """Affiche la barre lat√©rale avec les configurations."""
    with st.sidebar:
        st.title("‚öôÔ∏è Configuration")
        
        # S√©lection du mod√®le
        provider_type = st.selectbox(
            "Mod√®le",
            options=[p.value for p in ProviderType],
            format_func=lambda x: x.capitalize(),
            key="provider_selector"
        )

        # Mise √† jour du provider s√©lectionn√©
        if provider_type != st.session_state.selected_provider:
            run_async(change_provider(provider_type))

        # Configuration du mod√®le s√©lectionn√©
        if provider_type:
            provider = ProviderType(provider_type)
            
            # Affichage des champs selon le type de mod√®le
            if provider in [ProviderType.MISTRAL, ProviderType.GEMINI, ProviderType.DEEPSEEK]:
                api_key = st.text_input(
                    f"Cl√© API {provider.value}",
                    type="password",
                    value=st.session_state.config_manager.get_api_key(provider) or ""
                )
                
                if api_key:
                    st.session_state.config_manager.save_api_key(provider, api_key)
                    run_async(change_provider(provider_type))
                    
            elif provider in [ProviderType.LM_STUDIO, ProviderType.OLLAMA]:
                col1, col2 = st.columns([2, 1])
                
                with col1:
                    base_url = st.text_input(
                        f"URL API {provider.value}",
                        value=st.session_state.config_manager.get_model_config(provider).base_url or "",
                        help=f"URL de base pour l'API {provider.value} locale"
                    )
                
                config = st.session_state.config_manager.get_model_config(provider)
                
                with col2:
                    # Liste des mod√®les disponibles
                    if provider == ProviderType.OLLAMA and base_url:
                        models = run_async(get_ollama_models(base_url))
                        logger.debug(f"Mod√®les Ollama trouv√©s: {models}")
                    else:
                        models = ["llama2", "mistral", "vicuna"]

                    model_name = st.selectbox(
                        "Mod√®le",
                        options=models,
                        index=0 if config.name not in models else models.index(config.name)
                    )
                
                if base_url:
                    config.base_url = base_url
                    config.name = model_name
                    st.session_state.config_manager.save_model_config(config)
                    run_async(change_provider(provider_type))
            
        # Param√®tres du mod√®le
        st.subheader("Param√®tres")
        temperature = st.slider(
            "Temp√©rature",
            min_value=0.0,
            max_value=1.0,
            value=0.7,
            step=0.1,
            help="Contr√¥le la cr√©ativit√© des r√©ponses"
        )
        st.session_state["temperature"] = temperature
        
        # Param√®tres audio
        st.subheader("Audio")
        audio_enabled = st.checkbox(
            "Activer l'audio",
            value=st.session_state.config_manager.app_config.audio_enabled
        )
        
        if audio_enabled != st.session_state.config_manager.app_config.audio_enabled:
            st.session_state.config_manager.app_config.audio_enabled = audio_enabled
            st.session_state.config_manager.save_config()

async def process_chat_response(prompt: str):
    """
    Traite la r√©ponse du chat de mani√®re asynchrone.
    
    Args:
        prompt: Message de l'utilisateur
    """
    try:
        # R√©cup√©ration du provider actuel
        if not st.session_state.get("current_provider"):
            provider_type = ProviderType(st.session_state.selected_provider)
            st.session_state.current_provider = await initialize_provider(
                provider_type
            )
        
        if not st.session_state.current_provider:
            st.error("Aucun provider LLM initialis√©")
            return

        # Conversion des messages de la session en objets Message
        chat_messages: List[Message] = []
        for msg in st.session_state.messages:
            chat_messages.append(
                Message(
                    role=msg["role"],
                    content=msg["content"],
                    timestamp=msg.get("timestamp", time.time())
                )
            )

        # Ajout du nouveau message
        chat_messages.append(
            Message(
                role="user",
                content=prompt,
                timestamp=time.time()
            )
        )

        # G√©n√©ration de la r√©ponse
        return await st.session_state.current_provider.chat_completion(
            messages=chat_messages,
            temperature=st.session_state.get("temperature", 0.7)
        )

    except Exception as e:
        st.error(f"Erreur lors de la g√©n√©ration de la r√©ponse: {e}")
        if st.session_state.get("current_provider"):
            await st.session_state.current_provider.close()
            st.session_state.current_provider = None
        return None

def render_chat_interface():
    """Affiche l'interface de chat principale."""
    st.title("üí¨ Chat LLM")
    
    # Affichage des messages
    for msg in st.session_state.messages:
        with st.chat_message(msg["role"]):
            st.write(msg["content"])
    
    # Zone de saisie
    if prompt := st.chat_input("Votre message..."):
        # Ajout du message utilisateur
        st.session_state.messages.append({
            "role": "user",
            "content": prompt,
            "timestamp": time.time()
        })
        
        with st.chat_message("user"):
            st.write(prompt)

        # R√©ponse du mod√®le
        with st.chat_message("assistant"):
            with st.spinner("R√©flexion en cours..."):
                response = run_async(process_chat_response(prompt))
                
                if response:
                    st.write(response)
                    # Ajout de la r√©ponse √† l'historique
                    st.session_state.messages.append({
                        "role": "assistant",
                        "content": response,
                        "timestamp": time.time()
                    })

def render_audio_controls():
    """Affiche les contr√¥les audio si activ√©s."""
    if not st.session_state.config_manager.app_config.audio_enabled:
        return

    cols = st.columns(2)
    
    with cols[0]:
        if st.button("üé§ Enregistrer", key="record"):
            try:
                run_async(st.session_state.audio_manager.start_recording())
                st.success("Enregistrement d√©marr√©")
            except AudioError as e:
                st.error(f"Erreur d'enregistrement: {e}")
    
    with cols[1]:
        if st.button("‚èπÔ∏è Stop", key="stop"):
            try:
                audio_data, sample_rate = run_async(
                    st.session_state.audio_manager.stop_recording()
                )
                # TODO: Conversion audio -> texte
                st.success("Enregistrement termin√©")
            except AudioError as e:
                st.error(f"Erreur d'arr√™t d'enregistrement: {e}")

def main():
    """Point d'entr√©e principal de l'application."""
    render_sidebar()
    render_chat_interface()
    render_audio_controls()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        st.error(f"Erreur critique de l'application: {e}")
        logger.exception("Erreur critique")
